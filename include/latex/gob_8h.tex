\hypertarget{gob_8h}{\section{gob.\+h File Reference}
\label{gob_8h}\index{gob.\+h@{gob.\+h}}
}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=121pt]{gob_8h__dep__incl}
\end{center}
\end{figure}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structraygan__general__object}{raygan\+\_\+general\+\_\+object}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\hypertarget{gob_8h_a206ffc251b8ccefb3e952a12d9afeef9}{typedef struct \\*
\hyperlink{structraygan__general__object}{raygan\+\_\+general\+\_\+object} {\bfseries gob}}\label{gob_8h_a206ffc251b8ccefb3e952a12d9afeef9}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{gob_8h_a9d8fa5b2a38077865071ba07a3a5db7c}{cleanup\+\_\+garbage} (void $\ast$)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{gob_8h_a9d8fa5b2a38077865071ba07a3a5db7c}{\index{gob.\+h@{gob.\+h}!cleanup\+\_\+garbage@{cleanup\+\_\+garbage}}
\index{cleanup\+\_\+garbage@{cleanup\+\_\+garbage}!gob.\+h@{gob.\+h}}
\subsubsection[{cleanup\+\_\+garbage}]{\setlength{\rightskip}{0pt plus 5cm}void cleanup\+\_\+garbage (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{target}
\end{DoxyParamCaption}
)}}\label{gob_8h_a9d8fa5b2a38077865071ba07a3a5db7c}
G\+A\+R\+B\+A\+G\+E C\+O\+L\+L\+E\+C\+T\+I\+O\+N M\+E\+T\+H\+O\+D. this method name could change. but I want to keep it simple.

Simply steps through the garbage chain, calling the cleanup function for each node, terminating when N\+U\+L\+L.

The cleanup function could quite simply be set to free(). But it should be set to something otherwise it will do nothing and skip the object, leaking it into memory. In that case it really is your fault for not setting a cleanup function. 